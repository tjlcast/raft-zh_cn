

# raft 重点记录
----
<!-- MarkdownTOC -->

- [helper](#helper)
- [5.4 安全性](#54-%E5%AE%89%E5%85%A8%E6%80%A7)
- [集群成员变更](#%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4)
- [日志压缩](#%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9)

<!-- /MarkdownTOC -->

<a id="helper"></a>
### helper

There are some [videos](http://thesecretlivesofdata.com/raft/) that can help we better understand the theory.

<a id="54-%E5%AE%89%E5%85%A8%E6%80%A7"></a>
### 5.4 安全性
问题：一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目。

方法：保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目。即在任何基于领导人的一致性算法中（Leader 来确定提交的Log项），领导人都必须存储所有已经提交的日志条目。raft中leader的日志条目传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。Raft使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。

实现：候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。

重点：

+ *获选人得到集群大部分节点*:（节点数量固定，大部分指大于 [self + nodes + nodes] 中的node ）
+ *一样新*：  通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。
+ *保证大部分节点都有*： 领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。
+ Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。
+ Raft 的 RPCs 都是幂等的
+ Raft 可以选举并维持一个稳定的领导人，需满足：
    - 广播时间（broadcastTime） << 选举超时时间（electionTimeout） << 平均故障间隔时间（MTBF）
+ 提交之前任期内的日志条目
    - [leader如何确定Log的提交](https://www.jianshu.com/p/cf1c1d9b632b)

<a id="%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4"></a>
# 集群成员变更
- https://www.cnblogs.com/hzmark/p/raft_4.html
- [这个很通俗的解读](https://www.jianshu.com/p/79fc50fb0b49)
- https://blog.csdn.net/zhang_shuai_2011/article/details/38585725

<a id="%E6%97%A5%E5%BF%97%E5%8E%8B%E7%BC%A9"></a>
# 日志压缩
使用快照

|参数 | 解释|
|:-----|:-----|
|term   | **<font color=#FF0000 >领导人的任期号</font>**|
|leaderId|    领导人的 Id，以便于跟随者重定向请求|
|lastIncludedIndex|   快照中包含的最后日志条目的索引值|
|lastIncludedTerm  |  快照中包含的最后日志条目的任期号|
|offset  |分块在快照中的字节偏移量|
|data[]  |原始数据|
|done    |如果这是最后一个分块则为 true|